#include "main.h"
#include "effect.h"
#include "launch_effect.h"
#include "draw.h"
#include <string.h>
#include <avr/io.h>


// Главная функция. AVR входит в эту функцию во время загрузки.
int main (void)
{
	//Эта функция инициирует порты ввода-вывода, таймеры, прерывания и последовательные связи
	ioinit();
	
	//Эта переменная определяет, какой слой в настоящее время разрабатывается.
	current_layer = 1;

	int i;
	
	// Функция ожидания
	// Эта функция используется в 3-х целях:
	// 1) Задержка запуска каких-либо прерываний, так как рисование куба вызывает много "шума", что может запутать ISP-программиста.
	// 2) Обработчит события нажатия кнопки для перехода в режим RS232 (выбор автономного режима работы или синхронного).
	// 3) Случайная последовательность процессов (отработки эффектов).
	i = bootwait();

	//Команда устанавливает флаг глобального прерывания (I) в регистре статуса (SREG), т.е. разрешает прерывание.
	//С этого начинается процедура обрисовки куба.
	sei();

	//Если функция bootwait() возвращает 2: переходим в режим RS-232.
	if (i == 2)
	{
		rs232();
	}

	//Результат функции bootwait(), всё кроме 2: создаёт удивительные эффекты. Бесконечный цикл (цикл навегда). =)
	while (1)
	{
		// Показывать эффекты в определённом порядке
		for (i=0; i<EFFECTS_TOTAL; i++)
		launch_effect(i);
		
		//Показывать эффекты в рандомном порядке
		//Закомментируйте две стороки кода выше и раскомментируйте одну строку ниже, если хотите, чтобы эффекты
		//выводились в случайном порядке.
		//launch_effect(rand()%EFFECTS_TOTAL);
	}
	
}

/*
Функция ISR(TIMER2_COMP_vect). Мультиплексор текущего кадрового буфера.
Эта функция вызывается прерыванием, которое генерируется таймером 2.
Каждый раз, когда он работает, он делает следующее:
1) Отключаем землю на всех слоях;
2) Закрываем (отключаем) выводы на всех сдвиговых регистрах 74HC574;
3) Загрузка текущего слоя из буфера куба на массив сдвигового регистра;
4) Открываем (включаем) выводы на всех сдвиговых регистрах 74HC574;
5) Включение текущего слоя;
6) Увеличение счётчика текущего слоя (переход к следующему слою), чтобы следующий слой рисовался при выполнении этой функции.
*/
ISR(TIMER2_COMP_vect)
{
	int i;

	LAYER_SELECT = 0x00;// Отключить все слои. Отключаем землю всех слоёв.
	OE_PORT |= OE_MASK; // Устанавливаем OE(включение/отключение выхода Q0-Q7 сдвигового регистра 74HC574) в
	//высокий логический уровень, т.е. отключаем вывод данных на портах Q0-Q7
	
	//Цикл по 8-ми байтам данных, в текущем слое(уровне). Другими словами: загружаем данные (1байт = 8бит) в текущем слое на каждый ряд.
	for (i = 0; i < 8; i++)
	{
		//Установка значений (данных) на шине данных в конкретном сдвиговом регистре (отдельный ряд в текущем слое).
		PORTA = cube[current_layer][i];
		//Переключение к следующему сдвиговому регистру 74HC574 (ряду в текущем слое) и загрузка в него данных (в следующей итерации цикла)
		LATCH_ADDR = (LATCH_ADDR & LATCH_MASK_INV) | (LATCH_MASK & (i+1));
	}

	OE_PORT &= ~OE_MASK;//Устанавливаем OE(включение/отключение выхода Q0-Q7 сдвигового регистра 74HC574) в
	//низкий логический уровень, т.е. включаем вывод данных на портах Q0-Q7
	
	LAYER_SELECT = (0x01 << current_layer); //Включаем землю для текущего слоя (включаем текущий слой)

	//Увеличение счётчика текущего слоя (переход к следующему слою), чтобы следующий слой рисовался при выполнении этой функции.
	current_layer++;
	//Так как счет ведётся от 0-7, то устанавливаем current_layer в 0, когда он достигает 8.
	if (current_layer == 8)
	current_layer = 0;
	
}


void ioinit (void)
{
	DDRA = 0xff;	//Порт A выставляем все единицы (0x11111111). Все элементы портаA настроены на ВЫХОД!
	
	DDRB = 0xef; //Порт B выставляем все единицы кроме четвертого бита (0b11101111).
	//Все элементы порта A настроены на ВЫХОД, кроме четвертого элемента, он настроен на ВХОД!
	DDRC = 0xff;	//Все элементы порта С делаем ВЫХОДНЫМИ!
	DDRD = 0xdf;	//Порт D. Все элементы ВЫХОДНЫЕ, кроме пятого (пятого бита), он ВХОДНОЙ!
	
	
	PORTA = 0x00; //Задаём всем элементам портаA режим "отключены"
	PORTC = 0x00; //Задаём всем элементам портаB режим "отключены"
	PORTB = 0x10; //Задаём всем элементам портаC режим "отключены", кроме пятого элемента, ему задаём режим "включен".
	//Это означает что на пятый элемент портаС подается напряжение +5V.
	PORTD = 0x20; //Задаём всем элементам портаD режим "отключены", кроме шестого элемента, ему задаём режим "включен".
	//Это означает что на шестой элемент портаD подается напряжение +5V.


	// Таймер 2
	//TCCR2 |= (1 << CS21) | (1 << CS22);
	//TCCR2 |= (1 << WGM21);
	//TIMSK |= (1 << OCIE2);
	OCR2 = 10; //Регистр сравнения. Сюда мы записываем то, с чем надо сравнить.
	TCCR2 = 0xD; //Настройки TCCR2 регистра: МП/128, CTC. (B,C,D,E,F)
	TCNT2 = 0x00; //Счетный регистр. В него-то и будет считать наш счетчик. Начальное занчение = 0.
	TIMSK = 0x80; //Регистр маски прерываний от таймеров/счетчиков. Настройки TIMSK регистра: OCIE2 - флаг разрешения прерывания по совпадению Т2.


	// Инициализация RS232
	// Скорость передачи USART определяется в MYUBRR
	UBRRH = MYUBRR >> 8; //0
	UBRRL = MYUBRR; //скорость обмена 38400 бод
	
	// UCSRC - регистр управления USART
	// bit 7		Выбор регистра. Этот разряд определяет, в какой из регистров модуля производится запись.
	//Если разряд установлен в «1», обращение производится к регистру UCSRC.
	//Если же разряд сброшен в «0», обращение производится к регистру UBRRH.
	// bit 6		Режим работы USART. Если разряд сброшен в «0», модуль USART работает в асинхронном режиме.
	//Если разряд установлен в «1», то модуль USART работает в синхронном режиме.
	// bit 5-4      Режим работы схемы контроля и формирования четности. Эти разряды определяют функционирование схем
	//контроля и формирования четности. Настройки: UPM1=0, UPM2=0 - Disabled.
	// bit 3        Количество стопбитов. Этот разряд определяет количество стоп битов, посылаемых передатчиком.
	//Если разряд сброшен в «0», передатчик посылает 1 стоп бит, если установлен в «1», то 2 стоп бита.
	//Для приемника содержимое этого разряда безразлично.
	// bit 2-1      Формат посылок. Совместно с разрядом UCSZ2 эти разряды определяют количество
	//разрядов данных в посылках (размер слова). Размер слова = 8-bit.
	// bit 0        Полярность тактового сигнала. Значение этого разряда определяет момент выдачи
	//и считывания данных на выводах модуля. Разряд используется только при работе в синхронном режиме.
	//При работе в асинхронном режиме он должен быть сброшен в «0».
	UCSRC  = 0b10000110;
	// Включение RS232. Разрешение приема (Rx(вход)) и передачи (Tx(выход)).
	UCSRB = (1<<RXEN)|(1<<TXEN);
	// UDR - регистр данных. Отправить пустой байт, чтобы указать питание.
	UDR = 0x00;

}


unsigned int bootwait (void)
{
	//мигание зелёного и красного индикаторов
	unsigned int x = 0;
	LED_PORT |= LED_GREEN;
	while (1)
	{
		x++; // увеличиваем x на единицу
		srand(x); // инициализация генератора случайных чисел
		
		delay_ms(10000);
		LED_PORT &= ~LED_GREEN; // зелёный выключен, красный включен
		LED_PORT |= LED_RED; //снова меняем зажигание индикаторов
		
		//Слушаем нажатие кнопки и возвращаем соответсвующий номер
		if (!(PIND & RS232_BTN))// если кнопка RS323 включена, то возвращаем 2
		return 2;

		if (!(PINB & MAIN_BTN))//когда нажата основная кнопка, то возвращаем 1
		return 1;
		
		delay_ms(1000);
		//То же, что и выше. Делается это, потому что есть две задержки в этом цикле, используемые для мигания красно-зеленого светодиода.
		LED_PORT &= ~LED_RED; //зелёный выключен, красный включен
		LED_PORT |= LED_GREEN; //снова меняем зажигание индикаторов
		
		//Слушаем нажатие кнопки и возвращаем соответствующий номер
		if (!(PIND & RS232_BTN))// если кнопка RS323 включена, то возвращаем 2
		return 2;

		if (!(PINB & MAIN_BTN))//когда нажата основная кнопка, то возвращаем 1
		return 1;
	}
}

void ON_cube(){
		
}

void OFF_cube(){
	
}

//Принимаем данные с компьютера и загружаем его в буффер куба
void rs232(void)
{
	int x = 1;
	int y = 2;
	int z = 3;
	int escape = 0;
	int tempval;
	
	while (1)
	{
		//Включение красного индикатора для отладки.
		//При переключении статуса, каждый раз код ждёт байт, который будет получен.
		//LED_PORT ^= LED_RED;
		LED_PORT = 0b00111100; 
		
		
		// Подождите, пока не был получен байт
		while ( !(UCSRA & (1<<RXC)) );
		
		//Загрузка принятого байта из RS232 в буфер
		tempval = UDR;
		
		//Нижняя срочка, если её раскомментировать, данные вернуться обратно на компьютер. Обеспечиваем "эхо".
		UDR = tempval;
		
		
		if(tempval == 1){
			for (int i=0; i<EFFECTS_TOTAL; i++){
				launch_effect(i);	
			}
		}
		
		if(tempval == 2){
			launch_effect(21);
		}
		
		
		
		//(1 открыто)----------------ЭТО УЖЕ Я ДОБАВЛЯЛ (на основании того, что ты мне присылал)-------------//
		
		// Подождите, пока не был получен байт
		
		//while ( !(UCSRA & (1<<RXC)) );
		//currentSymbol=UDR;
		
		
		
		//for(int i=0; i<3; i++){
			
			//x++;
		//}
		
		
		//commandBuffer[0] = 102;
		//commandBuffer[1] = 110;
		//UDR = commandBuffer[1];
		
		
		
		//Загрузка принятого байта из RS232 в буфер
		//надо принимать все данные из порта пока не встретим нуль-терминатор
		
		/*
		if (currentSymbol==0){	//end of commn=and
			
			while(!UCSRA & (1<<UDRE));
			UDR = commandBuffer[1];
				for(int i=0;i<4;++i){
				while(!UCSRA & (1<<UDRE));
				UDR = commandBuffer[i];
				
				if(commandBuffer[i]==102){
					effect_stringfly2("Ф");
				}
			}
			
			}else{
			commandBuffer[commandBufferIndex]=currentSymbol;
			++commandBufferIndex;
		}
		*/

		/*if(UDR!=0){//end of command
		commandBuffer[commandBufferIndex]=UDR;
		commandBuffer[commandBufferIndex]='t';
		effect_stringfly2("Ф");
		//	while(!UCSRA & (1<<UDRE));
		UDR = (uint8_t)commandBuffer[commandBufferIndex];
		++commandBufferIndex;
		//	UDR = commandBufferIndex;
		}
		else
		{
		commandBufferIndex=1;
		
		
		
		if(commandBuffer[1]=='f'){
		
		}
		//				effect_stringfly2("Ф");
		
		
		
		}*/
		
		
		//(1 закрыто)----------------------------------------------------------------------------------------//
		
		
		
		
		
		
		//(2 открыто)-------------------ИЗНАЧАЛЬНО БЫЛО ТАК (заточено под приём байт для буфера)------------------//
		//-------------------------------я всё это закоментировал, чтобы оно мне пока не мешало-------------------//
		
	/*	
		// Подождите, пока не был получен байт
		while ( !(UCSRA & (1<<RXC)) );
		
		//Загрузка принятого байта из RS232 в буфер
		tempval = UDR;
		
		//Нижняя срочка, если её раскомментировать, данные вернуться обратно на компьютер. Обеспечиваем "эхо".
		UDR = tempval;
		
		// Переходим в режим синхронизации
		if (tempval == 0xff) //0b11111111
		{
			// Ждём следующий байт
			while ( !(UCSRA & (1<<RXC)) );
		
			// Получаем следующий байт
			tempval = UDR;

			//Сигнал синхронизации получен
			//Сброс счётчиков x и y в 0
			if (tempval == 0x00) //0b00000000
			{
				x = 0;
				y = 0;
				escape = 1;
			}
		//Если байт 0x00 не получен, то приступаем к байту, который мы только что получили.
		}

		if (escape == 0)
		{
			//Загрузка данных текущей позиции в буффер
			fb[x][y] = tempval;

			// Проверяем, достигли ли мы пределов массива
			if (y == 7)
			{
				if (x == 7)
				{
					//На этот момент все данные в массив загружены. Сброс обоих счётчиков.
					y = 0;
					x = 0;
					//Копируем данные на куб.
					tmp2cube();
				} else
					{
					//Слой загружается, сбрасываем y, увеличиваем x.
					x++;
					y = 0;
				}
			} else
				{
					// Мы находимся в середине (в процессе) загрузки слоя. Увеличиваем y.
					y++;
				}
		
		} else
			{
				escape = 0;
			}
		
*/		
		//(2 закрыто)---------------------------------------------------------------------------------------------//
	}
	
}


